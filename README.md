#HTML Parser

Структура:

* index.php - входной скрипт
* source.html - тестовый файл для файлового источника

core:
* class Client - клиент парсера
* class ParserException - исключение парсера

parser:
* Parser - общий интерфейс для всех парсеров
* AllTagsParser - парсер с маской для всех возможных тегов
* AnchorParser - парсер с маской для ссылок
* ImageParser - парсер с маской для изображений 
* TableParser - парсер с маской для тегов таблиц
* UserDefineParser - пользовательский парсер. В конструкторе указывается маска парсера

reporter:
* Reporter - общий интерфейс для всех репортеров
* HTMLReporter - строит отчёт в виде HTML
* XMLReporter - строит отчёт в виде XML и либо выводит его в браузер, либо сохраняет на диск, если в конструктор
передано имя файла
 
source:
* Source - общий интерфейс для всех источников
* DataBaseSource - источник из БД (**не реализован**)
* DirectSource - прямой источник. В конструктор передаётся HTML-код
* FileSource - файловый источник. В конструктор передаётся путь к файлу с HTML-кодом
* UrlSource - URL-источник. В конструктор передаётся URL сайта, который необходимо проанализировать

view:
* result.php - HTML-шаблон для HTML-репортера

![Case diagram](case.png)

##КАК РАБОТАЕТ?

Создаётся клиент, в конструктор которго передаются экземпляры источника и репортера. Если результат необходимо
получить в виде массива, то репортер не указывается.

`$client = new Client(new UrlSource('http://move.ru/'), new XMLReporter());`

Добавляются необходимые парсеры:

```
$client->addParser(new AnchorParser());
$client->addParser(new ImageParser());
$client->addParser(new TableParser());
$client->addParser(new UserDefineParser('dd|link|form|input|select|option'));
```

Если необходимо проверить все доступные теги, то можно использовать всего один парсер:

`$client->addParser(new AllTagsParser());`

Запускаем процесс:

`$client->parse();`

##МАСШТАБИРОВАНИЕ
Весь процесс работы состоит всего из 3х функций - конструктора клиента, добавления парсеров и запуска.

Добавление нового источника: необходимо создать новый класс, реализующий интерфейс **Source**, который
возвращает HTML-код как строку.

Добавление нового парсера: необходимо создать новый класс, реализующий интерфейс **Parser**, который
возвращает маску тегов (перечисление тегов через разделитель "|").

Добавление нового репортера: необходимо создать новый класс, реализующий интерфейс **Reporter**, которому
передаётся массив [tagName => count] для построения отчёта